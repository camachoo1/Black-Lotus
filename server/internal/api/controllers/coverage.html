
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">black-lotus/internal/api/controllers/auth/oauth_controller.go (94.8%)</option>
				
				<option value="file1">black-lotus/internal/api/controllers/auth/user_controller.go (96.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "net/url"
        "os"

        "github.com/labstack/echo/v4"

        "black-lotus/internal/domain/auth/services"
)

type OAuthControllerInterface interface {
        GetGitHubAuthURL(ctx echo.Context) error
        HandleGitHubCallback(ctx echo.Context) error
        GetGoogleAuthURL(ctx echo.Context) error
        HandleGoogleCallback(ctx echo.Context) error
}

// OAuthController handles OAuth authentication endpoints
type OAuthController struct {
        oauthService   services.OAuthServiceInterface
        sessionService services.SessionServiceInterface
}

// NewOAuthController creates a new OAuth controller
func NewOAuthController(oauthService services.OAuthServiceInterface, sessionService services.SessionServiceInterface) *OAuthController <span class="cov8" title="1">{
        return &amp;OAuthController{
                oauthService:   oauthService,
                sessionService: sessionService,
        }
}</span>

// GetGitHubAuthURL returns the GitHub OAuth URL
func (c *OAuthController) GetGitHubAuthURL(ctx echo.Context) error <span class="cov8" title="1">{
        returnTo := ctx.QueryParam("returnTo")

        if returnTo == "" </span><span class="cov8" title="1">{
                returnTo = "/" // Default to home if not specified
        }</span>

        // Get base URL from request for redirect
        <span class="cov8" title="1">scheme := ctx.Scheme()
        host := ctx.Request().Host

        // Important: Use redirect URI without query parameters
        redirectURI := fmt.Sprintf("%s://%s/api/auth/github/callback", scheme, host)

        // Pass returnTo as state parameter for security
        authURL := c.oauthService.GetAuthorizationURL("github", redirectURI, returnTo)

        return ctx.JSON(http.StatusOK, map[string]string{
                "url": authURL,
        })</span>
}

// HandleGitHubCallback processes GitHub OAuth callback
func (c *OAuthController) HandleGitHubCallback(ctx echo.Context) error <span class="cov8" title="1">{
        // Get code from query parameters
        code := ctx.QueryParam("code")
        if code == "" </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{
                        "error": "Missing code parameter",
                })
        }</span>

        // Get state parameter (contains our returnTo value)
        <span class="cov8" title="1">state := ctx.QueryParam("state")
        returnTo := "/" // Default to callback page
        if state != "" </span><span class="cov8" title="1">{
                decodedState, err := url.QueryUnescape(state)
                if err == nil </span><span class="cov8" title="1">{
                        // If we have a valid state, use it for returnTo
                        returnTo = decodedState
                }</span>
        }

        // Authenticate with GitHub
        <span class="cov8" title="1">user, err := c.oauthService.AuthenticateGitHub(ctx.Request().Context(), code)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Authentication failed: " + err.Error(),
                })
        }</span>

        // Create session
        <span class="cov8" title="1">session, err := c.sessionService.CreateSession(ctx.Request().Context(), user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Failed to create session",
                })
        }</span>

        // Get frontend URL from environment or use default
        <span class="cov8" title="1">frontendURL := os.Getenv("FRONTEND_URL")
        if frontendURL == "" </span><span class="cov0" title="0">{
                frontendURL = "http://localhost:3000"
        }</span>

        <span class="cov8" title="1">redirectURL := frontendURL + "/auth/callback?returnTo=" + url.QueryEscape(returnTo)

        // Set access token cookie
        accessCookie := new(http.Cookie)
        accessCookie.Name = "access_token"
        accessCookie.Value = session.AccessToken
        accessCookie.Expires = session.AccessExpiry
        accessCookie.Path = "/"
        accessCookie.HttpOnly = true
        accessCookie.Secure = true
        accessCookie.SameSite = http.SameSiteLaxMode

        // Set refresh token cookie
        refreshCookie := new(http.Cookie)
        refreshCookie.Name = "refresh_token"
        refreshCookie.Value = session.RefreshToken
        refreshCookie.Expires = session.RefreshExpiry
        refreshCookie.Path = "/"
        refreshCookie.HttpOnly = true
        refreshCookie.Secure = true
        refreshCookie.SameSite = http.SameSiteLaxMode

        ctx.SetCookie(accessCookie)
        ctx.SetCookie(refreshCookie)

        // Redirect to frontend
        return ctx.Redirect(http.StatusFound, redirectURL)</span>
}

// GetGoogleAuthURL returns the Google OAuth URL
func (c *OAuthController) GetGoogleAuthURL(ctx echo.Context) error <span class="cov8" title="1">{
        returnTo := ctx.QueryParam("returnTo")

        if returnTo == "" </span><span class="cov0" title="0">{
                returnTo = "/" // Default to home if not specified
        }</span>

        // Get base URL from request for redirect
        <span class="cov8" title="1">scheme := ctx.Scheme()
        host := ctx.Request().Host

        // Important: Use redirect URI without query parameters
        redirectURI := fmt.Sprintf("%s://%s/api/auth/google/callback", scheme, host)

        // Pass returnTo as state parameter for security
        authURL := c.oauthService.GetAuthorizationURL("google", redirectURI, returnTo)

        return ctx.JSON(http.StatusOK, map[string]string{
                "url": authURL,
        })</span>
}

// HandleGoogleCallback processes Google OAuth callback
func (c *OAuthController) HandleGoogleCallback(ctx echo.Context) error <span class="cov8" title="1">{
        // Get code from query parameters
        code := ctx.QueryParam("code")
        if code == "" </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{
                        "error": "Missing code parameter",
                })
        }</span>

        // Get state parameter (contains our returnTo value)
        <span class="cov8" title="1">state := ctx.QueryParam("state")
        returnTo := "/" // Default to callback page
        if state != "" </span><span class="cov8" title="1">{
                decodedState, err := url.QueryUnescape(state)
                if err == nil </span><span class="cov8" title="1">{
                        // If we have a valid state, use it for returnTo
                        returnTo = decodedState
                }</span>
        }

        // Get redirect URI (must match the one used to get auth URL)
        <span class="cov8" title="1">scheme := ctx.Scheme()
        host := ctx.Request().Host
        redirectURI := fmt.Sprintf("%s://%s/api/auth/google/callback", scheme, host)

        // Authenticate with Google
        user, err := c.oauthService.AuthenticateGoogle(ctx.Request().Context(), code, redirectURI)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Authentication failed: " + err.Error(),
                })
        }</span>

        // Create session
        <span class="cov8" title="1">session, err := c.sessionService.CreateSession(ctx.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Failed to create session",
                })
        }</span>

        // Get frontend URL from environment or use default
        <span class="cov8" title="1">frontendURL := os.Getenv("FRONTEND_URL")
        if frontendURL == "" </span><span class="cov0" title="0">{
                frontendURL = "http://localhost:3000"
        }</span>

        <span class="cov8" title="1">redirectURL := frontendURL + "/auth/callback?returnTo=" + url.QueryEscape(returnTo)

        // Set access token cookie
        accessCookie := new(http.Cookie)
        accessCookie.Name = "access_token"
        accessCookie.Value = session.AccessToken
        accessCookie.Expires = session.AccessExpiry
        accessCookie.Path = "/"
        accessCookie.HttpOnly = true
        accessCookie.Secure = true
        accessCookie.SameSite = http.SameSiteLaxMode // Critical for OAuth

        // Set refresh token cookie
        refreshCookie := new(http.Cookie)
        refreshCookie.Name = "refresh_token"
        refreshCookie.Value = session.RefreshToken
        refreshCookie.Expires = session.RefreshExpiry
        refreshCookie.Path = "/"
        refreshCookie.HttpOnly = true
        refreshCookie.Secure = true
        refreshCookie.SameSite = http.SameSiteLaxMode // Critical for OAuth

        ctx.SetCookie(accessCookie)
        ctx.SetCookie(refreshCookie)

        // Redirect to frontend
        return ctx.Redirect(http.StatusTemporaryRedirect, redirectURL)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        "fmt"
        "log"
        "net/http"
        "reflect"
        "strconv"
        "strings"

        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"

        "black-lotus/internal/domain/auth/services"
        "black-lotus/internal/domain/auth/validators"
        "black-lotus/internal/models"
)

type UserController struct {
        userService    services.UserServiceInterface
        sessionService services.SessionServiceInterface
        validator      *validator.Validate
}

type UserControllerInterface interface {
        RegisterUser(ctx echo.Context) error
        LoginUser(ctx echo.Context) error
        LogoutUser(ctx echo.Context) error
        RefreshToken(ctx echo.Context) error
        GetUserProfile(ctx echo.Context) error
        GetCSRFToken(ctx echo.Context) error
        GetUserProfileWithTrips(ctx echo.Context) error
}

func NewUserController(userService services.UserServiceInterface, sessionService services.SessionServiceInterface) *UserController <span class="cov8" title="1">{
        validate := validator.New()

        // This is critical - register struct-level validation
        validate.RegisterTagNameFunc(func(fld reflect.StructField) string </span><span class="cov8" title="1">{
                name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
                if name == "-" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov8" title="1">return name</span>
        })

        // Register custom validators
        <span class="cov8" title="1">validators.RegisterCustomValidators(validate)

        return &amp;UserController{
                userService:    userService,
                sessionService: sessionService,
                validator:      validate,
        }</span>
}

// Creates a new user account and logs them in automatically
func (c *UserController) RegisterUser(ctx echo.Context) error <span class="cov8" title="1">{
        var input models.CreateUserInput

        // Validate request data
        if err := ctx.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{
                        "error": "Invalid request body",
                })
        }</span>

        <span class="cov8" title="1">if err := c.validator.Struct(input); err != nil </span><span class="cov8" title="1">{
                // Extract validation errors
                if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                        errorMessages := make(map[string]string)

                        for _, e := range validationErrors </span><span class="cov8" title="1">{
                                switch e.Tag() </span>{
                                case "required":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = fmt.Sprintf("%s is required", e.Field())</span>
                                case "email":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = "Please enter a valid email address"</span>
                                case "min":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = fmt.Sprintf("%s must be at least %s characters long", e.Field(), e.Param())</span>
                                case "containsuppercase":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = "Password must contain at least one uppercase letter"</span>
                                case "containslowercase":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = "Password must contain at least one lowercase letter"</span>
                                case "containsnumber":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = "Password must contain at least one number"</span>
                                case "containsspecialchar":<span class="cov8" title="1">
                                        errorMessages[e.Field()] = "Password must contain at least one special character"</span>
                                default:<span class="cov0" title="0">
                                        errorMessages[e.Field()] = fmt.Sprintf("%s is invalid", e.Field())</span>
                                }
                        }

                        <span class="cov8" title="1">return ctx.JSON(http.StatusBadRequest, map[string]interface{}{
                                "error":   "Validation failed",
                                "details": errorMessages,
                        })</span>
                }

                <span class="cov0" title="0">return ctx.JSON(http.StatusBadRequest, map[string]string{
                        "error": err.Error(),
                })</span>
        }

        // Create the user
        <span class="cov8" title="1">user, err := c.userService.CreateUser(ctx.Request().Context(), input)
        if err != nil </span><span class="cov8" title="1">{
                // Check for specific errors
                if err.Error() == "user with this email already exists" </span><span class="cov8" title="1">{
                        return ctx.JSON(http.StatusConflict, map[string]string{
                                "error": err.Error(),
                        })
                }</span>
                <span class="cov8" title="1">return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Failed to create user",
                })</span>
        }

        // Create a session to automatically log in the new user
        <span class="cov8" title="1">session, err := c.sessionService.CreateSession(ctx.Request().Context(), user.ID)
        if err != nil </span><span class="cov8" title="1">{
                // User was created, but session creation failed
                // We'll still return success but log the error
                log.Printf("Failed to create session for new user: %v", err)
        }</span> else<span class="cov8" title="1"> {
                // Set access token cookie
                accessCookie := new(http.Cookie)
                accessCookie.Name = "access_token"
                accessCookie.Value = session.AccessToken
                accessCookie.Expires = session.AccessExpiry
                accessCookie.Path = "/"
                accessCookie.HttpOnly = true
                // For production
                accessCookie.Secure = true
                accessCookie.SameSite = http.SameSiteStrictMode

                // Set refresh token cookie
                refreshCookie := new(http.Cookie)
                refreshCookie.Name = "refresh_token"
                refreshCookie.Value = session.RefreshToken
                refreshCookie.Expires = session.RefreshExpiry
                refreshCookie.Path = "/"
                refreshCookie.HttpOnly = true
                // For production
                refreshCookie.Secure = true
                refreshCookie.SameSite = http.SameSiteStrictMode

                ctx.SetCookie(accessCookie)
                ctx.SetCookie(refreshCookie)
        }</span>

        <span class="cov8" title="1">return ctx.JSON(http.StatusCreated, user)</span>
}

// LoginUser authenticates a user and creates a session
func (c *UserController) LoginUser(ctx echo.Context) error <span class="cov8" title="1">{
        var input models.LoginUserInput

        // Validate request data
        if err := ctx.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{
                        "error": "Invalid request body",
                })
        }</span>

        <span class="cov8" title="1">if err := c.validator.Struct(input); err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Authenticate user credentials
        <span class="cov8" title="1">user, err := c.userService.LoginUser(ctx.Request().Context(), input)
        if err != nil </span><span class="cov8" title="1">{
                // Generic error for security (don't reveal if email or password was wrong)
                return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "Invalid credentials. Please check your email and password and try again.",
                })
        }</span>

        // Create a session for the authenticated user
        <span class="cov8" title="1">session, err := c.sessionService.CreateSession(ctx.Request().Context(), user.ID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Session creation error: %v", err)
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Failed to create session: " + err.Error(),
                })
        }</span>

        // Set access token cookie
        <span class="cov8" title="1">accessCookie := new(http.Cookie)
        accessCookie.Name = "access_token"
        accessCookie.Value = session.AccessToken
        accessCookie.Expires = session.AccessExpiry
        accessCookie.Path = "/"
        accessCookie.HttpOnly = true
        // For production
        accessCookie.Secure = true
        accessCookie.SameSite = http.SameSiteStrictMode

        // Set refresh token cookie
        refreshCookie := new(http.Cookie)
        refreshCookie.Name = "refresh_token"
        refreshCookie.Value = session.RefreshToken
        refreshCookie.Expires = session.RefreshExpiry
        refreshCookie.Path = "/"
        refreshCookie.HttpOnly = true
        // For production
        refreshCookie.Secure = true
        refreshCookie.SameSite = http.SameSiteStrictMode

        ctx.SetCookie(accessCookie)
        ctx.SetCookie(refreshCookie)

        return ctx.JSON(http.StatusOK, user)</span>
}

// LogoutUser ends the current user session
func (c *UserController) LogoutUser(ctx echo.Context) error <span class="cov8" title="1">{
        // Try to get both tokens
        accessCookie, accessErr := ctx.Cookie("access_token")
        refreshCookie, refreshErr := ctx.Cookie("refresh_token")

        // Check if already logged out
        if accessErr != nil &amp;&amp; refreshErr != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusOK, map[string]string{
                        "message": "Already logged out",
                })
        }</span>

        // Delete session by access token if it exists
        <span class="cov8" title="1">if accessErr == nil </span><span class="cov8" title="1">{
                err := c.sessionService.EndSessionByAccessToken(ctx.Request().Context(), accessCookie.Value)
                if err != nil </span><span class="cov8" title="1">{
                        // Log the error but continue
                        log.Printf("Failed to end session by access token: %v", err)
                }</span>
        }

        // Delete session by refresh token if it exists
        <span class="cov8" title="1">if refreshErr == nil </span><span class="cov8" title="1">{
                err := c.sessionService.EndSessionByRefreshToken(ctx.Request().Context(), refreshCookie.Value)
                if err != nil </span><span class="cov8" title="1">{
                        // Log the error but continue
                        log.Printf("Failed to end session by refresh token: %v", err)
                }</span>
        }

        // Clear access token cookie
        <span class="cov8" title="1">accessCookieClear := new(http.Cookie)
        accessCookieClear.Name = "access_token"
        accessCookieClear.Value = ""
        accessCookieClear.MaxAge = -1 // Expire immediately
        accessCookieClear.Path = "/"
        ctx.SetCookie(accessCookieClear)

        // Clear refresh token cookie
        refreshCookieClear := new(http.Cookie)
        refreshCookieClear.Name = "refresh_token"
        refreshCookieClear.Value = ""
        refreshCookieClear.MaxAge = -1 // Expire immediately
        refreshCookieClear.Path = "/"
        ctx.SetCookie(refreshCookieClear)

        return ctx.JSON(http.StatusOK, map[string]string{
                "message": "Successfully logged out",
        })</span>
}

func (c *UserController) RefreshToken(ctx echo.Context) error <span class="cov8" title="1">{
        // Get refresh token from cookie
        refreshCookie, err := ctx.Cookie("refresh_token")
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "No refresh token provided",
                })
        }</span>

        // Use the refresh token to get a new access token
        <span class="cov8" title="1">session, err := c.sessionService.RefreshAccessToken(ctx.Request().Context(), refreshCookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "Invalid refresh token",
                })
        }</span>

        // Set the new access token cookie
        <span class="cov8" title="1">accessCookie := new(http.Cookie)
        accessCookie.Name = "access_token"
        accessCookie.Value = session.AccessToken
        accessCookie.Expires = session.AccessExpiry
        accessCookie.Path = "/"
        accessCookie.HttpOnly = true

        // For production
        accessCookie.Secure = true
        accessCookie.SameSite = http.SameSiteLaxMode

        ctx.SetCookie(accessCookie)

        return ctx.JSON(http.StatusOK, map[string]string{
                "message": "Access token refreshed successfully",
        })</span>
}

func (c *UserController) GetUserProfile(ctx echo.Context) error <span class="cov8" title="1">{
        // Get access token from cookie
        accessCookie, err := ctx.Cookie("access_token")
        if err != nil </span><span class="cov8" title="1">{
                // No access token - check if there's a refresh token
                _, refreshErr := ctx.Cookie("refresh_token")
                if refreshErr != nil </span><span class="cov8" title="1">{
                        return ctx.JSON(http.StatusUnauthorized, map[string]string{
                                "error": "Not authenticated",
                        })
                }</span>

                // Has refresh token but no access token - client should refresh
                <span class="cov8" title="1">return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "Access token expired",
                        "code":  "token_expired",
                })</span>
        }

        // Validate access token
        <span class="cov8" title="1">session, err := c.sessionService.ValidateAccessToken(ctx.Request().Context(), accessCookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "Invalid access token",
                        "code":  "token_invalid",
                })
        }</span>

        // Get user from session
        <span class="cov8" title="1">user, err := c.userService.GetUserByID(ctx.Request().Context(), session.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Failed to get user",
                })
        }</span>

        <span class="cov8" title="1">return ctx.JSON(http.StatusOK, user)</span>
}

func (c *UserController) GetCSRFToken(ctx echo.Context) error <span class="cov8" title="1">{
        token := ctx.Get("csrf").(string)

        return ctx.JSON(http.StatusOK, map[string]string{
                "csrf_token": token,
        })
}</span>

// GetUserProfileWithTrips retrieves a user's profile with their trips
func (c *UserController) GetUserProfileWithTrips(ctx echo.Context) error <span class="cov8" title="1">{
        // Get access token from cookie
        accessCookie, err := ctx.Cookie("access_token")
        if err != nil </span><span class="cov8" title="1">{
                // No access token - check if there's a refresh token
                _, refreshErr := ctx.Cookie("refresh_token")
                if refreshErr != nil </span><span class="cov8" title="1">{
                        return ctx.JSON(http.StatusUnauthorized, map[string]string{
                                "error": "Not authenticated",
                        })
                }</span>

                // Has refresh token but no access token - client should refresh
                <span class="cov8" title="1">return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "Access token expired",
                        "code":  "token_expired",
                })</span>
        }

        // Validate access token
        <span class="cov8" title="1">session, err := c.sessionService.ValidateAccessToken(ctx.Request().Context(), accessCookie.Value)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusUnauthorized, map[string]string{
                        "error": "Invalid access token",
                        "code":  "token_invalid",
                })
        }</span>

        // Parse pagination parameters
        <span class="cov8" title="1">limit, _ := strconv.Atoi(ctx.QueryParam("limit"))
        offset, _ := strconv.Atoi(ctx.QueryParam("offset"))

        user, err := c.userService.GetUserWithTrips(ctx.Request().Context(), session.UserID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{
                        "error": "Failed to get user profile with trips",
                })
        }</span>

        <span class="cov8" title="1">return ctx.JSON(http.StatusOK, user)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
